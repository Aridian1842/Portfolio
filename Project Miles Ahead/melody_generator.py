'''
Author:     Christopher Shoe
Project:    Miles_Ahead
Purpose:    A MelodyEncoderDecoder specific to the lookback RNN model.

Code was built while significantly referencing public examples from the
Magenta documentation on GitHub:
https://github.com/tensorflow/magenta

Project is solely for academic purposes and not for sale or distribution of any kind.  
'''
from magenta.lib import melodies_lib

NUM_SPECIAL_EVENTS = melodies_lib.NUM_SPECIAL_EVENTS
NO_EVENT = melodies_lib.NO_EVENT
STEPS_PER_BAR = 16

MIN_NOTE = 25 #Inclusive
MAX_NOTE = 128 #Exclusive
TRANSPOSE_TO_KEY = 7 #G Major

#The number of special input indices and label values other than the events 
#in note range.
NUM_SPECIAL_INPUTS = 20
NUM_SPECIAL_LABELS = 15
NUM_BINARY_TIME_COUNTERS = 5


class MelodyEncoderDecoder(melodies_lib.MelodyEncoderDecoder):
  """A MelodyEncoderDecoder specific to the lookback RNN model.
  Attributes:
    num_model_events: The number of different melody events that can be
        generated by this model.
  """

  def __init__(self):
    """Initializes the MelodyEncoderDecoder."""
    super(MelodyEncoderDecoder, self).__init__(MIN_NOTE, MAX_NOTE,
                                               TRANSPOSE_TO_KEY)
    self.num_model_events = self.max_note - self.min_note + NUM_SPECIAL_EVENTS

  @property
  def input_size(self):
    return 3 * self.num_model_events + NUM_SPECIAL_INPUTS

  @property
  def num_classes(self):
    return self.num_model_events + NUM_SPECIAL_LABELS

  def melody_event_to_model_event(self, melody_event):
    """Collapses a melody event value into a zero-based index range.
    Args:
      melody_event: A MonophonicMelody event value. -2 = no event,
          -1 = note-off event, [0, 127] = note-on event for that midi pitch.
    Returns:
      An int in the range [0, self._num_model_events). 0 = no event,
      1 = note-off event, [2, self._num_model_events) = note-on event for
      that pitch relative to the [self._min_note, self._max_note) range.
    """
    if melody_event < 0:
      return melody_event + NUM_SPECIAL_EVENTS
    return melody_event - self.min_note + NUM_SPECIAL_EVENTS

  def model_event_to_melody_event(self, model_event):
    """Expands a zero-based index value to its equivalent melody event value.
    Args:
      model_event: An int in the range [0, self._num_model_events).
          0 = no event, 1 = note-off event,
          [2, self._num_model_events) = note-on event for that pitch relative
          to the [self._min_note, self._max_note) range.
    Returns:
      A MonophonicMelody event value. -2 = no event, -1 = note-off event,
      [0, 127] = note-on event for that midi pitch.
    """
    if model_event < NUM_SPECIAL_EVENTS:
      return model_event - NUM_SPECIAL_EVENTS
    return model_event - NUM_SPECIAL_EVENTS + self.min_note

  def melody_to_input(self, melody):
    """Returns the input vector for the last event in the melody.
    Returns a self.input_size length list of floats. Assuming MIN_NOTE = 48
    and MAX_NOTE = 84, self.input_size will = 121. Each index represents a
    different input signal to the model.
    Indices [0, 121):
    [0, 38): Event of current step.
    [38, 76): Event of next step if repeating 1 bar ago.
    [76, 114): Event of next step if repeating 2 bars ago.
    114: 16th note binary counter.
    115: 8th note binary counter.
    116: 4th note binary counter.
    117: Half note binary counter.
    118: Whole note binary counter.
    119: The current step is repeating 1 bar ago.
    120: The current step is repeating 2 bars ago.
    Args:
      melody: A melodies_lib.MonophonicMelody object.
    Returns:
      An input vector, an self.input_size length list of floats.
    """
    input_ = [0.0] * self.input_size

    # Last event.
    model_event = self.melody_event_to_model_event(
        melody.events[-1] if len(melody) >= 1 else NO_EVENT)
    input_[model_event] = 1.0

    # Next event if repeating 1 bar ago.
    if len(melody) < STEPS_PER_BAR:
      melody_event = NO_EVENT
    else:
      melody_event = melody.events[-STEPS_PER_BAR]
    model_event = self.melody_event_to_model_event(melody_event)
    input_[self.num_model_events + model_event] = 1.0

    # Next event if repeating 2 bars ago.
    if len(melody) < STEPS_PER_BAR * 2:
      melody_event = NO_EVENT
    else:
      melody_event = melody.events[-STEPS_PER_BAR * 2]
    model_event = self.melody_event_to_model_event(melody_event)
    input_[2 * self.num_model_events + model_event] = 1.0

    # Binary time counter giving the metric location of the *next* note.
    n = len(melody)
    for i in range(NUM_BINARY_TIME_COUNTERS):
      input_[3 * self.num_model_events + i] = 1.0 if (n / 2 ** i) % 2 else -1.0

    # Last event is repeating 1 bar ago.
    if (len(melody) >= STEPS_PER_BAR + 1 and
        melody.events[-1] == melody.events[-(STEPS_PER_BAR + 1)]):
      input_[3 * self.num_model_events + 5] = 1.0

    # Last event is repeating 2 bars ago.
    if (len(melody) >= 2 * STEPS_PER_BAR + 1 and
        melody.events[-1] == melody.events[-(2 * STEPS_PER_BAR + 1)]):
      input_[3 * self.num_model_events + 6] = 1.0

    return input_

  def melody_to_label(self, melody):
    """Returns the label for the last event in the melody.
    Returns an int the range [0, self.num_classes). Indices in the range
    [0, self.num_model_events) map to standard midi events. Indices
    self.num_model_events and self.num_model_events + 1 are signals to repeat
    events from earlier in the melody.
    Assuming MIN_NOTE = 48 and MAX_NOTE = 84, then self.num_classes = 40,
    self.num_model_events = 38, and the values will be as follows.
    Values [0, 40):
      [0, 38): Event of the last step in the melody, if not repeating 1 or 2
               bars ago.
      38: If the last event in the melody is repeating 1 bar ago, if not
          repeating 2 bars ago.
      39: If the last event in the melody is repeating 2 bars ago.
    Args:
      melody: A melodies_lib.MonophonicMelody object.
    Returns:
      A label, an int.
    """
    # If last step repeated 2 bars ago.
    if ((len(melody.events) <= 2 * STEPS_PER_BAR and
         melody.events[-1] == NO_EVENT) or
        (len(melody.events) > 2 * STEPS_PER_BAR and
         melody.events[-1] == melody.events[-(2 * STEPS_PER_BAR + 1)])):
      return self.num_model_events + 1

    # If last step repeated 1 bar ago.
    if (len(melody.events) > STEPS_PER_BAR and
        melody.events[-1] == melody.events[-(STEPS_PER_BAR + 1)]):
      return self.num_model_events

    # If last step didn't repeat 1 or 2 bars ago, use the specific event.
    return self.melody_event_to_model_event(melody.events[-1])

  def class_index_to_melody_event(self, class_index, melody):
    """Returns the melody event for the given class index.
    This is the reverse process of the self.melody_to_label method.
    Args:
      class_index: An int in the range [0, self.num_classes).
      melody: The melodies_lib.MonophonicMelody events list of the current
          melody.
    Returns:
      A melodies_lib.MonophonicMelody event value.
    """
    # Repeat 1 bar ago.
    if class_index == self.num_model_events + 1:
      if len(melody) < 2 * STEPS_PER_BAR:
        return NO_EVENT
      return melody.events[-(2 * STEPS_PER_BAR)]

    # Repeat 2 bars ago.
    if class_index == self.num_model_events:
      if len(melody) < STEPS_PER_BAR:
        return NO_EVENT
      return melody.events[-STEPS_PER_BAR]

    # Return the melody event for that class index.
    return self.model_event_to_melody_event(class_index)